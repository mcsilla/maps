<!DOCTYPE html> 
<html> 
  <head> 
    <meta charset='utf-8' />
    <title>Hungary</title> 
    <style>
      svg {
        background-color: blue;
      }

      .hungary {
        fill: orange;
        stroke: blue;
        stroke-width: 1;
      }
      .county {
        fill: green;
        stroke: blue;
        stroke-width: 1;
      }
      #county-1 {
        fill: red;
      }
      #county-2 {
        fill: green;
      }
      #county-3 {
        fill: blue;
      }
      #county-4 {
        fill: orange;
      }
      #county-5 {
        fill: pink;
      }
      #county-6 {
        fill: purple;
      }
      #county-7 {
        fill: navy;
      }
      #county-8 {
        fill: yellow;
      }
      #county-9 {
        fill: brown;
      }
      #county-10 {
        fill: violet;
      }
      #county-11 {
        fill: indigo;
      }
      #county-12 {
        fill: khaki;
      }
      #county-13 {
        fill: orangered;
      }
      #county-14 {
        fill: gray;
      }
      #county-15 {
        fill: magenta;
      }
      #county-16 {
        fill: gold;
      }
      #county-17 {
        fill: silver;
      }
      #county-18 {
        fill: white;
      }
      #county-19 {
        fill: black;
      }
    </style>
  </head>

<body>
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <script src="https://d3js.org/d3-array.v1.min.js"></script>
  <script src="https://d3js.org/d3-geo.v1.min.js"></script>
  <script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
  <script>
    
    let urlLocalHungary =    "/GeoJson/hungary.geojson"
    let urlLocalCounties =   "/GeoJson/countiesAndBP.geojson"
    let urlLocalDistricts =  "/GeoJson/districts.geojson"
    let urlLocalTowns =      "/GeoJson/towns.geojson"
    //let urlNationalityData = "/2011Nepszamlalas/resNew.json"
    let urlNationalityData = "resNew.json"

    const projection = d3.geoBaker(); //d3.geoAlbers()

    var scaleX;
    var scaleY;

    const padding = 10;

    const svgContainer = d3.select("body").append("svg");

    function makeRequest(method, url) {
      return new Promise(function (resolve, reject) {
        let xhr = new XMLHttpRequest();
        xhr.open(method, url);
        xhr.responseType = 'json';
        xhr.onload = function () {
          if (this.status >= 200 && this.status < 300) {
            resolve(xhr.response);
          } else {
            reject({
              status: this.status,
              statusText: xhr.statusText
            });
          }
        };
        xhr.onerror = function () {
          reject({
            status: this.status,
            statusText: xhr.statusText
          });
        };
        xhr.send();
      });
    }

    const collectingData = async url => {
      return makeRequest("GET", url);
    }

    lineFunction = d3.line()
                     .x(function(d) { return d.x; })
                     .y(function(d) { return d.y; })
                     .curve(d3.curveLinear);

    async function appendProjCoordinates(url) {
      let geomData = await collectingData(url);
      geomData.features.forEach(town => town.geometry.projectedCoordinates = town.geometry.coordinates.map(segment => segment.map(coord => projection(coord))));
      return geomData.features;

    }
 
    document.addEventListener("DOMContentLoaded", async function () 
          {let geomData = await appendProjCoordinates(urlLocalTowns);
                let hunData = await appendProjCoordinates(urlLocalHungary);
          
                let maxCoordX = d3.max(hunData[0].geometry.projectedCoordinates[0], (d) => d[0]);
                let maxCoordY = d3.max(hunData[0].geometry.projectedCoordinates[0], (d) => d[1]);
                let minCoordX = d3.min(hunData[0].geometry.projectedCoordinates[0], (d) => d[0]);
                let minCoordY = d3.min(hunData[0].geometry.projectedCoordinates[0], (d) => d[1]);
                let w = (maxCoordX - minCoordX) * 100;
                let h = (maxCoordY - minCoordY) * 100;
                scaleX = d3.scaleLinear()
                          .domain([minCoordX, maxCoordX])
                          .range([0, w]);
                scaleY = d3.scaleLinear()
                          .domain([minCoordY, maxCoordY])
                          .range([0, h]);
          
                geomData.forEach(town => town.geometry.polygon = town.geometry.projectedCoordinates.map(segment => segment.map(coord =>  
                   ({"x": padding + scaleX(coord[0]), "y": padding + scaleY(coord[1])})) ));
                
                svgContainer.attr("width", w + 2 * padding)
                            .attr("height", h + 2 * padding);
               
               let newGeomData = {};
               geomData.forEach((town, i) => {
                 let name = town.properties.NAME;
                 if (!newGeomData.hasOwnProperty(name)) {
                   newGeomData[name] = ({"geometry": town.geometry});
                 } else {
                   let coordsA = newGeomData[name].geometry.coordinates;
                   let coordsB = town.geometry.coordinates;
                   let projCoordsA = newGeomData[name].geometry.projectedCoordinates;
                   let projCoordsB = town.geometry.projectedCoordinates;
                   let polygonA = newGeomData[name].geometry.polygon;
                   let polygonB = town.geometry.polygon;
                   newGeomData[name].geometry.coordinates = coordsA.concat(coordsB);
                   newGeomData[name].geometry.projectedCoordinates = projCoordsA.concat(projCoordsB);
                   newGeomData[name].geometry.polygon = polygonA.concat(polygonB);
                 }
               });
          
               let nationsData = await collectingData(urlNationalityData);
          
               let myRegex = /^(\s*[JK]\d+\s)*/;
          
               nationsData.forEach(town => {
                 town.name = town.name.replace(myRegex, "");
               });
               
               //console.log(nationsData);
               //let townIndexNatData = {};
               
               let newNationsData = {};
               nationsData.forEach((town, i) => {
                 let name = town.name;
                 if (!newNationsData.hasOwnProperty(name)) {
                   newNationsData[name] = town;
                   delete newNationsData[name].name;
                 } else {
                   console.log("Error: towns listed multiple times.");
                 }
          
               });
          
               let townsNat = Object.keys(newNationsData);
               let townsGeom = Object.keys(newGeomData);
          
               //console.log(townsNat.length, townsGeom.length);
          
               let onlyTownsNat = [];
               let onlyTownsGeom = [];
               let bothNatGeom = [];
          
               townsNat.forEach(town => {
                if (townsGeom.indexOf(town) < 0) {
                  onlyTownsNat.push(town);
                }
                else {
                  bothNatGeom.push(town);
                }
               })
          
               townsGeom.forEach(town => {
                if (townsNat.indexOf(town) < 0) {
                  onlyTownsGeom.push(town);
                }
               })
          
               let mergedData = {};
               bothNatGeom.forEach(town => {
                mergedData[town] = ({"properties": newNationsData[town], "geometry": newGeomData[town].geometry});
                // = 
               });
          
          
          
               let missingData = ["–", "…", "..."];
          
               Object.keys(mergedData).forEach(town =>  {
                 let numOfGypsies = mergedData[town].properties.gypsy.replace(",", "");
                 let numOfHun = mergedData[town].properties.hungarian.replace(",", "");
                 if (missingData.indexOf(numOfGypsies) < 0 && missingData.indexOf(numOfHun) < 0) {
                   mergedData[town].properties["gypsyHunRatio"] = numOfGypsies / numOfHun;
                   //console.log(numOfGypsies, numOfHun, typeof numOfGypsies, typeof numOfHun, typeof mergedData[town].properties["gypsyHunRatio"]);  
                 }
                 else {
                  mergedData[town].properties["gypsyHunRatio"] = -1;
                 }
               } );
          
          
          
               let maxGypsyHunRatio = d3.max(Object.keys(mergedData), town => mergedData[town].properties["gypsyHunRatio"]);
               let minGypsyHunRatio = d3.min(Object.keys(mergedData), town => {
                let ratio = mergedData[town].properties["gypsyHunRatio"];
                if (ratio >= 0) {
                  return mergedData[town].properties["gypsyHunRatio"];
                }
               });
          
               const scale = d3.scaleLinear()
                               .domain([minGypsyHunRatio, maxGypsyHunRatio])
                               .range([100, 0]);
          
               Object.keys(mergedData).forEach(town => console.log(town, mergedData[town].properties["gypsy"], mergedData[town].properties["hungarian"],mergedData[town].properties["gypsyHunRatio"], scale(mergedData[town].properties["gypsyHunRatio"])));
          
          
               Object.keys(mergedData).forEach( (town, i) => {
                 //if (strangeTowns.indexOf(town.properties.NAME) >= 0) {
                   svgContainer.append("path") 
                               .attr("d", mergedData[town].geometry.polygon.map(poly => lineFunction(poly)))
                               .attr("id", `town-${i}`)
                               //.attr("fill", "red");
                               .attr("fill", (town) => { 
                                  if (mergedData[town].properties["gypsyHunRatio"] >= 0) {
                                    return "yellow";
                                  }
                                }); //else {
                               //    return `hsl(0, 100%, ${scale(mergedData[town].properties["gypsyHunRatio"])}%)`;
                               //  }//'#'+Math.floor(Math.random()*16777215).toString(16));
                               //});
                 //}
                });
             });



  </script>

</body>